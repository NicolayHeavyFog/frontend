# Прогресс

* `23 января` приступил к изучению ТЗ. (23.01.2022)
  * Решил придерживаться БЭМ методологии нэйминга и организации файлов, в том числе JS, чтобы не писать все в одном файле, и стараться делать во взрослому. Но тк для декларации и бандла нам нужен сборщик, а сборщики мы еще не изучали, я буду пользоваться `CommonJS`.

* `24 января` приступил к реализации.
  * Сначала напишу статически страницу, так, как представляю её, проверю на валидность, напишу классы. Позже буду писать JS. 
  * Решил таблицу представить в виде тега `<table>`, а не `<ul>`.

* `25 января` пишу JS.
  * Создаю все нужные элементы через JS. Оставил лишь базовые теги контейнеры, в которые буду вкладывать.
  * Пишу html разметку для модальных окон.
    * ``Обратил внимание, что в инпутах мадального окна, в плейсхолдерах, звездочки фиолетового цвета, и я не могу понять как это сделать не использовав костыли``

* `26 января` пишу JS для модального окна.
  * Писал свой дропдайн для контактов + писал валидацию

* `27 января` продолжаю писать JS для валидации формы, и прописывать поведение модальному окну.

Обратил внимание, что если в контейнере для контактов сделать направление `column-reverse`,
```css
.form__wrapper-contacts {
  ...
  flex-direction: column-reverse;
  ...
}
```
И в дочерних элементах использовать селекторы `:last-child` и `:first-child`,
```css
.form__container-contact:first-child {
    margin-bottom: 25px;
}

.form__container-contact:last-child {
    margin-top: 25px;
}
```
то `form__container-contact:last-child` работать не будет, что мне кажется сранным, потому как тот же самый класс с `:first-child` работает! Из-за этого я не могу сделать отступ сверху по макету. А `column-reverse` для меня обязательное свойство,
иначе происходит неправильное добавление новой формы для ввода контакта

* `28 января` делаю tooltip и кнопки изменения и удаления

* `29 января` исправляю мелкие косяки, добавил кнопку удаления контакта в форме.

Не совсем понял формулировку задания про Поиск, результаты поиска должна отображаться в таблице ниже, или согласно дополнительному заданию поиска с автодополнением, я должен их выводить в dropdown'е, как в каком-нибудь поисковике? 
Или я сначало должен сделать поиск с отображением результатов в таблице, а потом переделать его в dropdown, ради практики?

И еще плохо понимаю, как я могу сделать индиктор загрузки около кнопки 'Изменить' у клиента, и во время загрузки таблицы.
У меня есть предположение, что такие функции как изменить или загрузить список клиентов - они асинхронные,
и одновременно с асинхронными функциями я мог бы запускать не асинохронные, которые выполнялись бы сразу и отвечали за индикаторы загрузки, 
и как только ко мне приходил бы ответ с сервера, я бы убирал анимации, и отображал уже соотвествующий контент. 
Но я не знаю как эмулировать запрос, на который долго приходит ответ. И еще,
мне почему-то в теле ответа не приходит код ни 200, ни 401, никакой, так и должно быть?

```javascript
{"errors":[{"field":"contacts","message":"Не все добавленные контакты полностью заполнены"}]}
```

Или сам объект клиента.

И я делаю провреку вот так
```javascript
if (response.errors !== undefined) {
  const feedback = createFeedback(response.errors[0].message);
  buttonGroup.prepend(feedback);
} else {
    ...
}
``` 
Нормально ли так?

Обратил внимание, что можно добавить клиента, не добавив ни одного контакта, стоит ли сделать валидацию, чтобы хотя бы один контакт нужно было добавить при создании клиента?

Возникла проблема с сортировкой, не совсем понимаю, почему не работает такой сокращенный вариант через стрелочную функцию:

```javascript
    const listOfClients = await handlers.getClients(); //сначала получаю весь список клиентов
    // 'sort-reverse'
    tableBlock.tableHeaderSortButtonID.addEventListener('click', async ev => { // вешаю событие на кнопку сортировку 
        ev.preventDefault();

        let listOfClientsSortByIDs; // создаю массив для отсорированных эллементов

        tableBlock.tableHeaderSortButtonID.classList.toggle('sort-reverse'); // класс для того чтобы стрелочку менять около кнопки

        if (tableBlock.tableHeaderSortButtonID.classList.contains('sort-reverse')) { //item.sort((a,b) => a.id > b.id)
          listOfClientsSortByIDs = listOfClients.sort((a, b) => Number(a.id) - Number(b.id));

        } else {
          listOfClientsSortByIDs = listOfClients.sort((a, b) => Number(a.id) + Number(b.id));
        }
        handlers.refreshList(listOfClientsSortByIDs,tableBlock.tableBody,handlers,modalContainer);
    });
```
Но если писать более длинную форму сортировки, то сортирует как надо:

```javascript
    const listOfClients = await handlers.getClients();
    // 'sort-reverse'
    tableBlock.tableHeaderSortButtonID.addEventListener('click', async ev => {
        ev.preventDefault();
        
        let listOfClientsSortByIDs;
        
        tableBlock.tableHeaderSortButtonID.classList.toggle('sort-reverse');
        
        if (tableBlock.tableHeaderSortButtonID.classList.contains('sort-reverse')) { //item.sort((a,b) => a.id > b.id)
            listOfClientsSortByIDs = listOfClients.sort((a, b) => {
                if (a.id > b.id) return -1;
                if (a.id === b.id) return 0;
                if (a.id < b.id) return 1;
            });
        } else {
            listOfClientsSortByIDs = listOfClients.sort((a, b) => {
                if (a.id > b.id) return 1;
                if (a.id === b.id) return 0;
                if (a.id < b.id) return -1;
            });
        }
        handlers.refreshList(listOfClientsSortByIDs,tableBlock.tableBody,handlers,modalContainer);
    });
```

* `31 января` Делал сортировки.

По нажатию на кнопку изменения клиента у меня не происходит запрос на сервер, а я собираю информацию уже с имеющихся полей,
чтобы лишний раз не делать запросов. Но если скажете, чтобы я исправил, то я исправлю.


* `5 февраля` добавил анимацию для окон и спиннеры. Не собираю больше с полей данные, а запрашиваю с сервера, после нажатия на кнопку редактирования. 

* `6 февраля` добавил новый вид страницы с клиентом.